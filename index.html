<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Juego de Racionalización</title>
    
    <!-- 1. Tailwind CSS para el estilo -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- 2. KaTeX para renderizar matemáticas (CSS y JS) -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css" xintegrity="sha384-KiWSweCnCso1EwUKdZPoCqElMpgNIWlI9PzUMS1DBsPk2sGj/2If/F/5WhdoczD6" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.js" xintegrity="sha384-hIoBPJ1AWM5E0yKmKwdStgSfeimI4kLMBFhRMg5O0BCdPqjMKAaEaLcm9lCqVfG0" crossorigin="anonymous"></script>
    
    <!-- Fuentes de Google -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap" rel="stylesheet">

    <style>
        /* Estilo base del Godot */
        body {
            font-family: 'Inter', sans-serif;
            /* Color de fondo oscuro (de tu ColorRect) */
            background-color: #2e4053;
            color: white;
            /* Centrar el juego en la pantalla */
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 1rem;
        }

        /* Estilo para los botones (de tu StyleBoxFlat) */
        .option-btn {
            background-color: #34495e; /* style_normal.bg_color */
            border-bottom: 4px solid #2c3e50; /* style_normal.border_color */
            transition: all 0.15s ease-in-out;
            font-size: 1.25rem; /* 20px */
            font-weight: 600;
            border-radius: 0.5rem; /* 8px */
            padding: 1.5rem; /* 24px */
            min-height: 100px; /* Altura mínima para KaTeX */
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .option-btn:hover {
            background-color: #4a6572; /* style_hover.bg_color */
        }
        .option-btn:active {
            background-color: #5e8c91; /* style_pressed.bg_color */
            transform: translateY(2px);
            border-bottom-width: 2px;
        }
        .option-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            background-color: #34495e; /* Prevenir cambio de color al estar deshabilitado */
        }

        /* Botón de Reiniciar (de tu StyleBoxFlat) */
        .restart-btn {
            background-color: #1abc9c; /* style_normal.bg_color (Verde) */
            border-bottom: 4px solid #16a085; /* style_normal.border_color */
            transition: all 0.15s ease-in-out;
            font-size: 1.25rem; /* 20px */
            font-weight: 700;
            border-radius: 0.5rem; /* 8px */
            padding: 1.25rem 2rem; /* 20px 32px */
        }
        .restart-btn:hover {
            opacity: 0.85;
        }
        .restart-btn:active {
            transform: translateY(2px);
            border-bottom-width: 2px;
        }

        /* Animación de Feedback (de tu Tween) */
        .feedback-pop {
            animation: pop 0.5s cubic-bezier(0.18, 0.89, 0.32, 1.28); /* Trans-elastic */
        }
        @keyframes pop {
            0% { transform: scale(1.5); }
            100% { transform: scale(1); }
        }

        /* KaTeX necesita un tamaño de fuente base */
        .katex {
            font-size: 1.3em !important;
        }
        
        /* Ocultar elementos */
        .hidden {
            display: none;
        }
    </style>
</head>
<body class="bg-[#2e4053]">

    <!-- Contenedor principal del juego -->
    <div id="game-container" class="w-full max-w-4xl mx-auto p-4 md:p-8 rounded-lg bg-[#34495e] shadow-2xl">

        <!-- 1. HUD (Score, Timer, Vidas) -->
        <div id="hud" class="flex justify-between items-center mb-6 text-xl md:text-2xl font-bold">
            <!-- Etiqueta de Puntaje -->
            <div id="score-label">Puntaje: 0</div>
            <!-- Etiqueta del Timer -->
            <div id="timer-label" class="text-[#f1c40f] text-3xl md:text-4xl font-black">
                Tiempo: 15.0
            </div>
            <!-- Etiqueta de Vidas -->
            <div id="lives-label">Vidas: 3</div>
        </div>

        <!-- 2. Etiqueta de la Pregunta -->
        <div id="question-container" class="bg-[#2c3e50] p-6 rounded-lg shadow-inner min-h-[150px] flex items-center justify-center mb-6">
            <!-- El texto se insertará con KaTeX -->
            <div id="question-text" class="text-2xl md:text-3xl text-center">Cargando...</div>
        </div>

        <!-- 3. Botones de Opción -->
        <div id="options-container" class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
            <button class="option-btn" data-index="0">Opción 1</button>
            <button class="option-btn" data-index="1">Opción 2</button>
            <button class="option-btn" data-index="2">Opción 3</button>
        </div>

        <!-- 4. Etiqueta de Feedback -->
        <div id="feedback-label" class="text-center text-xl md:text-2xl font-semibold min-h-[40px]">
            ¡Elige la respuesta correcta!
        </div>

    </div>

    <!-- Pantalla de Fin de Juego (inicialmente oculta) -->
    <div id="game-over-screen" class="hidden w-full max-w-4xl mx-auto p-8 rounded-lg bg-[#34495e] shadow-2xl text-center">
        <h1 id="final-message" class="text-4xl font-bold mb-4">GAME OVER</h1>
        <p id="final-score" class="text-2xl mb-8">Puntaje Final: 0</p>
        <button id="restart-btn" class="restart-btn">
            Jugar de Nuevo
        </button>
    </div>


    <!-- 5. Lógica del Juego (JavaScript) -->
    <script>
        // --- Variables del Juego ---

        // 1. Base de datos de preguntas (con sintaxis LaTeX)
        const preguntas = [
            // Fáciles
            { "pregunta": "\\frac{1}{\\sqrt{2}}", "opciones": ["\\frac{\\sqrt{2}}{2}", "\\frac{1}{2}", "\\sqrt{2}"], "correcta": 0 },
            { "pregunta": "\\frac{3}{\\sqrt{3}}", "opciones": ["\\sqrt{3}", "1", "3\\sqrt{3}"], "correcta": 0 },
            { "pregunta": "\\frac{10}{\\sqrt{5}}", "opciones": ["5\\sqrt{5}", "\\sqrt{2}", "2\\sqrt{5}"], "correcta": 2 },
            // Medias
            { "pregunta": "\\frac{5}{2\\sqrt{3}}", "opciones": ["\\frac{5\\sqrt{3}}{3}", "\\frac{10\\sqrt{3}}{6}", "\\frac{5\\sqrt{3}}{6}"], "correcta": 2 },
            { "pregunta": "\\frac{7}{\\sqrt{5} - 1}", "opciones": ["\\frac{7(\\sqrt{5} + 1)}{4}", "\\frac{7(\\sqrt{5} - 1)}{4}", "\\frac{7\\sqrt{5}}{4}"], "correcta": 0 },
            { "pregunta": "\\frac{\\sqrt{2}}{\\sqrt{3}}", "opciones": ["\\frac{2}{3}", "\\frac{\\sqrt{6}}{3}", "\\frac{\\sqrt{2}}{3}"], "correcta": 1 },
            // Difíciles
            { "pregunta": "\\frac{2}{1 + \\sqrt{5}}", "opciones": ["\\frac{\\sqrt{5} - 1}{2}", "\\frac{2}{\\sqrt{5}}", "\\frac{1 - \\sqrt{5}}{2}"], "correcta": 0 },
            { "pregunta": "\\frac{1 + \\sqrt{2}}{1 - \\sqrt{2}}", "opciones": ["-3 - 2\\sqrt{2}", "-1", "3 + 2\\sqrt{2}"], "correcta": 0 }
        ];

        // 2. Estado del juego
        let pregunta_actual_idx = 0;
        let score = 0;
        let lives = 3;
        const TIME_PER_QUESTION = 15.0; // Segundos
        let timeLeft = TIME_PER_QUESTION;
        
        // 3. Variables de temporizadores
        let questionTimeout; // Para el timeout de la pregunta (Godot Timer)
        let displayInterval; // Para actualizar el texto del timer (Godot _process)
        let isAcceptingAnswers = false;

        // 4. Referencias a los nodos UI
        const gameContainer = document.getElementById('game-container');
        const gameOverScreen = document.getElementById('game-over-screen');
        
        const etiqueta_pregunta = document.getElementById('question-text');
        const etiqueta_feedback = document.getElementById('feedback-label');
        const botones_opcion = document.querySelectorAll('.option-btn');
        
        const etiqueta_score = document.getElementById('score-label');
        const etiqueta_lives = document.getElementById('lives-label');
        const etiqueta_timer = document.getElementById('timer-label');
        
        const boton_reiniciar = document.getElementById('restart-btn');
        const finalMessage = document.getElementById('final-message');
        const finalScore = document.getElementById('final-score');

        // --- Funciones del Juego ---

        // Se llama al cargar la página (equivalente a _ready)
        function startGame() {
            // 0. Barajar las preguntas
            preguntas.sort(() => 0.5 - Math.random());
            
            // 1. Reiniciar estado
            pregunta_actual_idx = 0;
            score = 0;
            lives = 3;
            isAcceptingAnswers = false;

            // 2. Mostrar/Ocultar pantallas
            gameContainer.classList.remove('hidden');
            gameOverScreen.classList.add('hidden');
            
            // 3. Cargar la primera pregunta y el HUD
            actualizar_hud();
            cargar_pregunta(pregunta_actual_idx);
        }

        // Actualiza el texto del puntaje y las vidas
        function actualizar_hud() {
            etiqueta_score.innerText = `Puntaje: ${score}`;
            etiqueta_lives.innerText = `Vidas: ${lives}`;
        }

        // Detiene los dos temporizadores
        function stopAllTimers() {
            clearInterval(displayInterval);
            clearTimeout(questionTimeout);
        }

        // Carga una pregunta específica en la UI
        function cargar_pregunta(index) {
            // Comprobar si perdimos por vidas
            if (lives <= 0) {
                mostrar_pantalla_final(false); // false = no ganó
                return;
            }
            
            // Comprobar si ganamos
            if (index >= preguntas.length) {
                mostrar_pantalla_final(true); // true = ganó
                return;
            }

            isAcceptingAnswers = true;
            const datos_pregunta = preguntas[index];
            
            // Actualizar textos de la UI (usando KaTeX)
            katex.render(datos_pregunta.pregunta, etiqueta_pregunta, { throwOnError: false, displayMode: true });
            etiqueta_feedback.innerText = "¡Elige la respuesta correcta!";
            etiqueta_feedback.className = "text-center text-xl md:text-2xl font-semibold min-h-[40px]"; // Resetear color
            
            botones_opcion.forEach((btn, i) => {
                // Usamos KaTeX para renderizar la opción en el botón
                katex.render(datos_pregunta.opciones[i], btn, { throwOnError: false });
                btn.disabled = false; // Reactivamos los botones
            });

            // ¡Iniciar el timer para esta pregunta!
            timeLeft = TIME_PER_QUESTION;
            etiqueta_timer.innerText = `Tiempo: ${timeLeft.toFixed(1)}`;
            stopAllTimers(); // Limpiar timers anteriores

            // Timer para actualizar el display (equiv. a _process)
            displayInterval = setInterval(() => {
                timeLeft -= 0.1;
                etiqueta_timer.innerText = `Tiempo: ${Math.max(0, timeLeft).toFixed(1)}`;
            }, 100);

            // Timer para el timeout de la pregunta (equiv. a Timer.timeout)
            questionTimeout = setTimeout(_on_timer_timeout, TIME_PER_QUESTION * 1000);
        }

        // Se llama cuando se presiona CUALQUIER botón de opción
        function _on_boton_presionado(event) {
            if (!isAcceptingAnswers) return; // Evitar clicks múltiples
            isAcceptingAnswers = false;
            
            stopAllTimers();
            
            const index_opcion = parseInt(event.currentTarget.dataset.index);
            const datos_pregunta = preguntas[pregunta_actual_idx];
            
            // Desactivar todos los botones
            botones_opcion.forEach(btn => btn.disabled = true);

            // 1. Comprobar si la respuesta es correcta
            if (index_opcion === datos_pregunta.correcta) {
                etiqueta_feedback.innerText = "¡CORRECTO!";
                etiqueta_feedback.className = "text-center text-xl md:text-2xl font-semibold min-h-[40px] text-green-400 feedback-pop";
                score += 10;
            } else {
                // Mostrar la respuesta correcta usando katex en el feedback
                etiqueta_feedback.innerHTML = `Incorrecto. La respuesta era: <span id="correct-answer"></span>`;
                const answerSpan = document.getElementById('correct-answer');
                katex.render(datos_pregunta.opciones[datos_pregunta.correcta], answerSpan, { throwOnError: false });
                
                etiqueta_feedback.className = "text-center text-xl md:text-2xl font-semibold min-h-[40px] text-red-400 feedback-pop";
                lives -= 1;
            }

            // 2. Actualizar el HUD
            actualizar_hud();
            
            // 3. Esperar un poco antes de pasar a la siguiente
            setTimeout(() => {
                // 4. Avanzar a la siguiente pregunta
                pregunta_actual_idx += 1;
                cargar_pregunta(pregunta_actual_idx);
            }, 1500); // 1.5 segundos
        }

        // Se llama si el Timer llega a 0
        function _on_timer_timeout() {
            if (!isAcceptingAnswers) return;
            isAcceptingAnswers = false;
            
            // Desactivar botones
            botones_opcion.forEach(btn => btn.disabled = true);
            
            // Penalizar
            etiqueta_feedback.innerText = "¡Se acabó el tiempo!";
            etiqueta_feedback.className = "text-center text-xl md:text-2xl font-semibold min-h-[40px] text-red-400 feedback-pop";
            lives -= 1;
            actualizar_hud();
            
            // Esperar y cargar la siguiente
            setTimeout(() => {
                pregunta_actual_idx += 1;
                cargar_pregunta(pregunta_actual_idx);
            }, 1500);
        }

        // Muestra el mensaje final del juego
        function mostrar_pantalla_final(gano_el_juego) {
            stopAllTimers();
            
            // Ocultar el juego, mostrar pantalla final
            gameContainer.classList.add('hidden');
            gameOverScreen.classList.remove('hidden');

            // Mostrar mensaje final
            if (gano_el_juego) {
                finalMessage.innerText = "¡FELICIDADES!\nCompletaste todas las preguntas.";
            } else {
                finalMessage.innerText = "GAME OVER\nTe has quedado sin vidas.";
            }
            
            finalScore.innerText = `Puntaje Final: ${score}`;
        }

        // --- Conectar Eventos ---

        // Iniciar el juego cuando el DOM esté listo
        document.addEventListener('DOMContentLoaded', startGame);

        // Conectar los botones de opción
        botones_opcion.forEach(btn => {
            btn.addEventListener('click', _on_boton_presionado);
        });

        // Conectar el botón de reiniciar
        boton_reiniciar.addEventListener('click', startGame); // Recarga el juego sin recargar la página

    </script>
</body>
</html>
